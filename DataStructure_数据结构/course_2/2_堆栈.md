> **摘要：** 

### 引：计算机如何进行表达式求值？

由两类对象构成：
- 运算数，如2、3、4；
- 运算符号：如+、-、*、/。
- 不同的运算符号优先级不一样。

**中缀表达式：a+b\*c-d/e**
**后缀表达式：abc\*+de/-**

例：62/3-42*+=?
遇到6、2、/，则6/2=3；
遇到3、-，则3-3=0；
遇到4、2、\*，则4\*2=8；
遇到+，则0+8=8。

计算策略：从左往右扫描，遇到数则存储，**遇到运算符号则将最近存储两个数计算** 。

则需要一种后进先出的数据结构，就是堆栈。

$T(N)=O(N)$

### 堆栈的抽象数据类型描述

堆栈（Stack）：具有一定约束的线性表。

插入数据：入栈（Push）
删除数据：出栈（Pop）
先入后出：Last In First Out（LIFO）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190915145108217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjgxNTYwOQ==,size_16,color_FFFFFF,t_70)

在使用Push()或Pop()前，通常调用IsFull()判断堆栈是否为满或调用IsEmpty()判断是否为空。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019091514533538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjgxNTYwOQ==,size_16,color_FFFFFF,t_70)

对于ABC入栈，不可能产生CAB的输出。

### 栈的顺序存储实现

使用数组存储。

```c
#define MaxSize <储存数据元素的最大个数>
typedef struct SNode *Stack;
struct SNode
{
    ElementType Data[MaxSize];
    int Top;
};
```

入栈：

```c
void Push(Stack PtrS, ElementType item)
{
    if (Ptrs->Top == MaxSize - 1)
    {
        printf("堆栈满") : return;
    }
    else
    {
        PtrS->Data[++(PtrS->Top)] = item;
        return;
    }
}
```

出栈。

```c
ElementType Pop(Stack PtrS)
{
    if (PtrS->Top == -1)
    {
        printf("堆栈空");
        return ERROR; // ERROR是ElementType的特殊值，标志错误
    }
    else
    {
        return (PtrS->Data[(PtrS->Top)--]);
    }
}
```

### 堆栈的链式存储实现

堆栈初始化；

```c
typedef struct SNode *Stack;
struct SNode
{
    ElementType Data;
    struct *Next;
};

Stack CreateStack()
{   /* 构建一个堆栈的头结点，返回指针 */
    Stack S;
    S = (Stack)malloc(sizeof(struct SNode));
    S->Next = NULL;
    return S;
}
```

Push()与Pop()不再展示。注意free()临时指针空间。

### 表达式求值及其他应用

对于中缀表达式，将运算符号放入堆栈中进行存储，遇到新运算符，运算符出栈时，比较优先级。

- 函数调用及递归实现
- 深度优先算法
- 回溯算法

