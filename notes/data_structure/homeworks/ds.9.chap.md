
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [选择题](#选择题)
  - [对于7个数进行冒泡排序，最坏情况下需要进行的比较次数为](#对于7个数进行冒泡排序最坏情况下需要进行的比较次数为)
  - [对一组包含10个元素的非递减有序序列，采用插入排序排成非递增序列，其可能的比较次数和移动次数分别是](#对一组包含10个元素的非递减有序序列采用插入排序排成非递增序列其可能的比较次数和移动次数分别是)
  - [希尔排序是稳定的（错）](#希尔排序是稳定的错)
  - [有一组记录（46,77,55,38,41,85），用堆排序建立的初始堆为](#有一组记录467755384185用堆排序建立的初始堆为)
- [讨论题](#讨论题)
  - [堆排序最适合解决什么样的问题？](#堆排序最适合解决什么样的问题)
- [编程题](#编程题)
  - [](#)

<!-- /code_chunk_output -->


## 选择题

### 对于7个数进行冒泡排序，最坏情况下需要进行的比较次数为

对于7个数进行冒泡排序，最坏情况下需要进行的比较次数为：
- 21
- 6 + 5 + ... + 1 = 21

### 对一组包含10个元素的非递减有序序列，采用插入排序排成非递增序列，其可能的比较次数和移动次数分别是

- 45, 44 对
- 54, 63
- 100, 54
- 100, 100

这是把递增序列拍成从大到小的序列。

顶多比较 $1 + ... + 9 = 45$ 次。

### 希尔排序是稳定的（错）

错，因为其虽然是插排的升级，但是不是把相邻的逆序对消除。

### 有一组记录（46,77,55,38,41,85），用堆排序建立的初始堆为

85,77,55,38,41,46

注意：
- 堆排序先建立最大堆
- 建立最大堆，从最小的最右下的一颗子树开始建堆

## 讨论题

### 堆排序最适合解决什么样的问题？

参考[漠Paranoid](https://www.icourse163.org/learn/ZJU-93001?tid=1465570445#/learn/forumpersonal?uid=1139020951)：
- 从全球70多亿人口中找出最富有的100个人
- 堆排序需要$O(n)$的时间建立最大堆，然后在100次内得出结果
- 依据：从大量的$N$个数据中找最大/最小的k个元素时，用堆排序是比较快的，可以在$O(N+klogN)$时间内得到解

我总结下，就是取 `n` 个数中 `k` 个最大值。

## 编程题

### 